"""MTG Engine V3 - Continuous Effects (CR 611)

This module implements continuous effects per the MTG Comprehensive Rules section 611.
Continuous effects modify characteristics of objects, control of objects, or rules
of the game for a certain duration.

Key concepts:
- CR 611.1: Continuous effects are generated by static abilities or one-shot effects
- CR 611.2: Duration types determine how long effects last
- CR 611.3: Effects modify objects that match their filter criteria

The layer system (CR 613) determines the order in which continuous effects are applied.
Effects are applied in layer order, and within each layer, in timestamp order
(with dependency exceptions).

Layers:
1. Copy effects
2. Control-changing effects
3. Text-changing effects
4. Type-changing effects
5. Color-changing effects
6. Ability-adding/removing effects
7. Power/toughness effects (with sublayers 7a-7e)
"""

from dataclasses import dataclass, field
from typing import (
    List, Dict, Optional, Set, Callable, Any, Tuple,
    Union, TYPE_CHECKING
)
from enum import Enum, auto

if TYPE_CHECKING:
    from ..game import Game
    from ..objects import GameObject, Permanent


# =============================================================================
# DURATION ENUM (CR 611.2)
# =============================================================================

class Duration(Enum):
    """Duration types for continuous effects (CR 611.2)

    Each duration type determines how long a continuous effect lasts and
    what conditions cause it to expire.
    """
    # PERMANENT: Static ability effect - lasts while source is on battlefield
    # For static abilities that generate effects as long as the source exists
    PERMANENT = "permanent"

    # END_OF_TURN: Expires at the cleanup step of the current turn (CR 514.2)
    # Common for pump spells: "Target creature gets +3/+3 until end of turn"
    END_OF_TURN = "end_of_turn"

    # NEXT_TURN: Expires at the end of the next turn
    # Used for effects like "until your next turn"
    NEXT_TURN = "next_turn"

    # UNTIL_LEAVES: Lasts until the source leaves the battlefield
    # For effects tied to a permanent's presence
    UNTIL_LEAVES = "until_leaves"

    # WHILE_ATTACHED: For Auras and Equipment - lasts while attached
    # Expires when the attachment relationship ends
    WHILE_ATTACHED = "while_attached"

    # CUSTOM: Uses a custom end_condition function
    # For complex durations not covered by other types
    CUSTOM = "custom"


# =============================================================================
# AFFECTED OBJECTS FILTER (CR 611.3)
# =============================================================================

@dataclass
class AffectedObjects:
    """Determines which objects are affected by a continuous effect (CR 611.3)

    A continuous effect affects objects that match its filter criteria.
    The filter can be a string shorthand for common patterns or a custom
    function for complex filtering logic.

    Attributes:
        filter_type: String identifier for the filter type. Common values:
            - "all_creatures": All creatures on the battlefield
            - "creatures_you_control": Creatures controlled by effect's controller
            - "creatures_opponents_control": Creatures controlled by opponents
            - "target": Specific targeted object(s)
            - "self": Only the source object itself
            - "other_creatures_you_control": Creatures you control except source
            - "all_permanents": All permanents on the battlefield
            - "lands_you_control": Lands controlled by effect's controller
            - "creatures_with_subtype": Creatures of a specific type (e.g., "Elves")

        filter_func: Optional custom filter function. Takes a GameObject and
            returns True if the object should be affected by the effect.
            When provided, this takes precedence over filter_type.
    """
    filter_type: str = "all_creatures"
    filter_func: Optional[Callable[['GameObject'], bool]] = None

    # For "target" filter_type - the specific object IDs being targeted
    target_ids: Set[int] = field(default_factory=set)

    # For "creatures_with_subtype" - the subtype to match
    subtype: Optional[str] = None

    def matches(
        self,
        obj: 'GameObject',
        source: Any,
        controller: Any
    ) -> bool:
        """Check if an object matches this filter

        Args:
            obj: The game object to check
            source: The source of the continuous effect
            controller: The controller of the continuous effect

        Returns:
            True if the object should be affected by the effect
        """
        # Custom filter function takes precedence
        if self.filter_func is not None:
            return self.filter_func(obj)

        # Handle string-based filter types
        if self.filter_type == "self":
            return obj is source or (hasattr(obj, 'object_id') and
                                     hasattr(source, 'object_id') and
                                     obj.object_id == source.object_id)

        if self.filter_type == "target":
            if hasattr(obj, 'object_id'):
                return obj.object_id in self.target_ids
            return False

        # For creature filters, check if object is a creature
        if self.filter_type.startswith("creature"):
            if not self._is_creature(obj):
                return False

            if self.filter_type == "all_creatures":
                return True

            if self.filter_type == "creatures_you_control":
                return self._is_controlled_by(obj, controller)

            if self.filter_type == "creatures_opponents_control":
                return not self._is_controlled_by(obj, controller)

            if self.filter_type == "other_creatures_you_control":
                if obj is source:
                    return False
                if hasattr(obj, 'object_id') and hasattr(source, 'object_id'):
                    if obj.object_id == source.object_id:
                        return False
                return self._is_controlled_by(obj, controller)

            if self.filter_type == "creatures_with_subtype":
                return self._has_subtype(obj, self.subtype)

        if self.filter_type == "all_permanents":
            return self._is_permanent(obj)

        if self.filter_type == "lands_you_control":
            return self._is_land(obj) and self._is_controlled_by(obj, controller)

        if self.filter_type == "nonland_permanents":
            return self._is_permanent(obj) and not self._is_land(obj)

        # Default: no match
        return False

    def _is_creature(self, obj: 'GameObject') -> bool:
        """Check if object is a creature"""
        if hasattr(obj, 'characteristics') and hasattr(obj.characteristics, 'types'):
            # Handle both set and list types
            types = obj.characteristics.types
            if hasattr(types, '__contains__'):
                # Check for CardType.CREATURE or string "creature"
                for t in types:
                    if str(t).lower() in ('creature', 'cardtype.creature'):
                        return True
        if hasattr(obj, 'types'):
            types = obj.types
            if hasattr(types, '__contains__'):
                for t in types:
                    if str(t).lower() in ('creature', 'cardtype.creature'):
                        return True
        if hasattr(obj, 'is_creature'):
            return obj.is_creature
        return False

    def _is_land(self, obj: 'GameObject') -> bool:
        """Check if object is a land"""
        if hasattr(obj, 'characteristics') and hasattr(obj.characteristics, 'types'):
            types = obj.characteristics.types
            if hasattr(types, '__contains__'):
                for t in types:
                    if str(t).lower() in ('land', 'cardtype.land'):
                        return True
        if hasattr(obj, 'types'):
            types = obj.types
            if hasattr(types, '__contains__'):
                for t in types:
                    if str(t).lower() in ('land', 'cardtype.land'):
                        return True
        if hasattr(obj, 'is_land'):
            return obj.is_land
        return False

    def _is_permanent(self, obj: 'GameObject') -> bool:
        """Check if object is a permanent"""
        if hasattr(obj, 'is_permanent'):
            return obj.is_permanent
        # On battlefield = permanent
        if hasattr(obj, 'zone'):
            return str(obj.zone).lower() in ('battlefield', 'zone.battlefield')
        return True  # Default assumption for objects we're checking

    def _is_controlled_by(self, obj: 'GameObject', controller: Any) -> bool:
        """Check if object is controlled by the specified controller"""
        if controller is None:
            return True  # No controller specified = match all

        obj_controller = None
        if hasattr(obj, 'controller'):
            obj_controller = obj.controller
        elif hasattr(obj, 'controller_id'):
            obj_controller = obj.controller_id

        if obj_controller is None:
            return True  # Can't determine controller

        # Compare controllers
        controller_id = controller
        if hasattr(controller, 'player_id'):
            controller_id = controller.player_id
        elif hasattr(controller, 'id'):
            controller_id = controller.id

        if hasattr(obj_controller, 'player_id'):
            return obj_controller.player_id == controller_id
        elif hasattr(obj_controller, 'id'):
            return obj_controller.id == controller_id

        return obj_controller == controller_id

    def _has_subtype(self, obj: 'GameObject', subtype: Optional[str]) -> bool:
        """Check if object has the specified subtype"""
        if subtype is None:
            return False

        subtypes = None
        if hasattr(obj, 'characteristics') and hasattr(obj.characteristics, 'subtypes'):
            subtypes = obj.characteristics.subtypes
        elif hasattr(obj, 'subtypes'):
            subtypes = obj.subtypes

        if subtypes is None:
            return False

        # Check for subtype (case-insensitive)
        subtype_lower = subtype.lower()
        for st in subtypes:
            if str(st).lower() == subtype_lower:
                return True

        return False


# =============================================================================
# MODIFICATION CLASS
# =============================================================================

@dataclass
class Modification:
    """A single modification to apply to an object

    Represents one change that a continuous effect makes to an object's
    characteristics. Multiple modifications can be part of a single effect.

    Attributes:
        mod_type: Type of modification. Common values:
            - "set_pt": Set power and toughness to specific values
            - "modify_pt": Add/subtract from power and toughness
            - "add_ability": Grant an ability
            - "remove_ability": Remove an ability
            - "add_type": Add a card type
            - "remove_type": Remove a card type
            - "add_subtype": Add a subtype
            - "remove_subtype": Remove a subtype
            - "set_color": Set colors (replacing existing)
            - "add_color": Add a color
            - "remove_color": Remove a color
            - "set_controller": Change controller
            - "add_keyword": Grant a keyword ability
            - "remove_keyword": Remove a keyword ability
            - "switch_pt": Switch power and toughness
            - "set_power": Set power only
            - "set_toughness": Set toughness only
            - "modify_power": Modify power only
            - "modify_toughness": Modify toughness only

        value: The modification value. Type depends on mod_type:
            - set_pt/modify_pt: Tuple[int, int] for (power, toughness)
            - set_power/modify_power/set_toughness/modify_toughness: int
            - add_ability/remove_ability: Ability object or string
            - add_type/remove_type: CardType or string
            - add_subtype/remove_subtype: string (subtype name)
            - set_color/add_color/remove_color: Color or Set[Color]
            - set_controller: Player or player_id
            - add_keyword/remove_keyword: string (keyword name)
    """
    mod_type: str
    value: Any = None

    def apply(self, obj: 'GameObject') -> None:
        """Apply this modification to an object

        Mutates the object's characteristics according to the modification
        type and value.

        Args:
            obj: The game object to modify
        """
        # Get characteristics container
        chars = None
        if hasattr(obj, 'characteristics'):
            chars = obj.characteristics
        else:
            chars = obj  # Object is its own characteristics container

        # ===== Power/Toughness modifications (Layer 7) =====

        if self.mod_type == "set_pt":
            # Set both power and toughness to specific values
            power, toughness = self.value
            if hasattr(chars, 'power'):
                chars.power = power
            elif hasattr(obj, 'power'):
                obj.power = power
            if hasattr(chars, 'toughness'):
                chars.toughness = toughness
            elif hasattr(obj, 'toughness'):
                obj.toughness = toughness

        elif self.mod_type == "modify_pt":
            # Add/subtract from power and toughness
            power_mod, toughness_mod = self.value
            if hasattr(chars, 'power') and chars.power is not None:
                chars.power += power_mod
            elif hasattr(obj, 'power') and obj.power is not None:
                obj.power += power_mod
            if hasattr(chars, 'toughness') and chars.toughness is not None:
                chars.toughness += toughness_mod
            elif hasattr(obj, 'toughness') and obj.toughness is not None:
                obj.toughness += toughness_mod

        elif self.mod_type == "set_power":
            if hasattr(chars, 'power'):
                chars.power = self.value
            elif hasattr(obj, 'power'):
                obj.power = self.value

        elif self.mod_type == "set_toughness":
            if hasattr(chars, 'toughness'):
                chars.toughness = self.value
            elif hasattr(obj, 'toughness'):
                obj.toughness = self.value

        elif self.mod_type == "modify_power":
            if hasattr(chars, 'power') and chars.power is not None:
                chars.power += self.value
            elif hasattr(obj, 'power') and obj.power is not None:
                obj.power += self.value

        elif self.mod_type == "modify_toughness":
            if hasattr(chars, 'toughness') and chars.toughness is not None:
                chars.toughness += self.value
            elif hasattr(obj, 'toughness') and obj.toughness is not None:
                obj.toughness += self.value

        elif self.mod_type == "switch_pt":
            # Switch power and toughness (Layer 7e)
            p = getattr(chars, 'power', None) or getattr(obj, 'power', None)
            t = getattr(chars, 'toughness', None) or getattr(obj, 'toughness', None)
            if p is not None and t is not None:
                if hasattr(chars, 'power'):
                    chars.power = t
                    chars.toughness = p
                elif hasattr(obj, 'power'):
                    obj.power = t
                    obj.toughness = p

        # ===== Ability modifications (Layer 6) =====

        elif self.mod_type == "add_ability":
            if hasattr(obj, 'add_ability'):
                obj.add_ability(self.value)
            elif hasattr(obj, 'granted_abilities'):
                obj.granted_abilities.append(self.value)
            elif hasattr(obj, 'abilities'):
                if isinstance(obj.abilities, list):
                    obj.abilities.append(self.value)
                elif isinstance(obj.abilities, set):
                    obj.abilities.add(self.value)

        elif self.mod_type == "remove_ability":
            if hasattr(obj, 'remove_ability'):
                obj.remove_ability(self.value)
            elif hasattr(obj, 'abilities'):
                if isinstance(obj.abilities, list):
                    if self.value in obj.abilities:
                        obj.abilities.remove(self.value)
                elif isinstance(obj.abilities, set):
                    obj.abilities.discard(self.value)

        elif self.mod_type == "add_keyword":
            if hasattr(obj, 'add_keyword'):
                obj.add_keyword(self.value)
            elif hasattr(obj, 'keywords'):
                if isinstance(obj.keywords, set):
                    obj.keywords.add(self.value)
                elif isinstance(obj.keywords, list):
                    if self.value not in obj.keywords:
                        obj.keywords.append(self.value)

        elif self.mod_type == "remove_keyword":
            if hasattr(obj, 'remove_keyword'):
                obj.remove_keyword(self.value)
            elif hasattr(obj, 'keywords'):
                if isinstance(obj.keywords, set):
                    obj.keywords.discard(self.value)
                elif isinstance(obj.keywords, list):
                    if self.value in obj.keywords:
                        obj.keywords.remove(self.value)

        # ===== Color modifications (Layer 5) =====

        elif self.mod_type == "set_color":
            # Set colors (replacing existing)
            colors = self.value if isinstance(self.value, (set, frozenset)) else {self.value}
            if hasattr(chars, 'colors'):
                chars.colors = set(colors)
            elif hasattr(obj, 'colors'):
                obj.colors = set(colors)

        elif self.mod_type == "add_color":
            colors_to_add = self.value if isinstance(self.value, (set, frozenset, list)) else [self.value]
            target = chars if hasattr(chars, 'colors') else obj
            if hasattr(target, 'colors'):
                if target.colors is None:
                    target.colors = set()
                for color in colors_to_add:
                    target.colors.add(color)

        elif self.mod_type == "remove_color":
            colors_to_remove = self.value if isinstance(self.value, (set, frozenset, list)) else [self.value]
            target = chars if hasattr(chars, 'colors') else obj
            if hasattr(target, 'colors') and target.colors is not None:
                for color in colors_to_remove:
                    target.colors.discard(color)

        # ===== Type modifications (Layer 4) =====

        elif self.mod_type == "add_type":
            types_to_add = self.value if isinstance(self.value, (set, frozenset, list)) else [self.value]
            target = chars if hasattr(chars, 'types') else obj
            if hasattr(target, 'types'):
                if target.types is None:
                    target.types = set()
                for card_type in types_to_add:
                    if isinstance(target.types, set):
                        target.types.add(card_type)
                    elif isinstance(target.types, list):
                        if card_type not in target.types:
                            target.types.append(card_type)

        elif self.mod_type == "remove_type":
            types_to_remove = self.value if isinstance(self.value, (set, frozenset, list)) else [self.value]
            target = chars if hasattr(chars, 'types') else obj
            if hasattr(target, 'types') and target.types is not None:
                for card_type in types_to_remove:
                    if isinstance(target.types, set):
                        target.types.discard(card_type)
                    elif isinstance(target.types, list):
                        if card_type in target.types:
                            target.types.remove(card_type)

        elif self.mod_type == "add_subtype":
            subtypes_to_add = self.value if isinstance(self.value, (set, frozenset, list)) else [self.value]
            target = chars if hasattr(chars, 'subtypes') else obj
            if hasattr(target, 'subtypes'):
                if target.subtypes is None:
                    target.subtypes = set()
                for subtype in subtypes_to_add:
                    if isinstance(target.subtypes, set):
                        target.subtypes.add(subtype)
                    elif isinstance(target.subtypes, list):
                        if subtype not in target.subtypes:
                            target.subtypes.append(subtype)

        elif self.mod_type == "remove_subtype":
            subtypes_to_remove = self.value if isinstance(self.value, (set, frozenset, list)) else [self.value]
            target = chars if hasattr(chars, 'subtypes') else obj
            if hasattr(target, 'subtypes') and target.subtypes is not None:
                for subtype in subtypes_to_remove:
                    if isinstance(target.subtypes, set):
                        target.subtypes.discard(subtype)
                    elif isinstance(target.subtypes, list):
                        if subtype in target.subtypes:
                            target.subtypes.remove(subtype)

        # ===== Control modifications (Layer 2) =====

        elif self.mod_type == "set_controller":
            if hasattr(obj, 'controller'):
                obj.controller = self.value
            if hasattr(obj, 'controller_id'):
                controller_id = self.value
                if hasattr(self.value, 'player_id'):
                    controller_id = self.value.player_id
                elif hasattr(self.value, 'id'):
                    controller_id = self.value.id
                obj.controller_id = controller_id


# =============================================================================
# CONTINUOUS EFFECT CLASS (CR 611)
# =============================================================================

@dataclass
class ContinuousEffect:
    """A continuous effect that modifies game state (CR 611)

    Continuous effects come from static abilities, spells, and abilities
    that create lasting modifications to objects or game rules.

    Attributes:
        source: The game object that is the source of this effect
        controller: The player who controls this effect
        layer: The layer number (1-7) where this effect applies (CR 613.1)
        sublayer: For layer 7, the sublayer ("a", "b", "c", "d", "e")
        timestamp: When this effect was created (for ordering within layers)
        duration: How long this effect lasts
        end_condition: Custom function for CUSTOM duration type
        affected: Filter for which objects are affected
        modification: The modification this effect applies
        dependency: List of effects this one depends on (CR 613.8)
    """
    source: Any
    controller: Any
    layer: int
    sublayer: Optional[str] = None
    timestamp: int = 0
    duration: Duration = Duration.PERMANENT
    end_condition: Optional[Callable[[], bool]] = None
    affected: AffectedObjects = field(default_factory=AffectedObjects)
    modification: Modification = field(default_factory=lambda: Modification("modify_pt", (0, 0)))
    dependency: List['ContinuousEffect'] = field(default_factory=list)

    # Internal tracking
    _effect_id: int = field(default=0, compare=False)
    _created_turn: int = field(default=0, compare=False)
    _source_id: Optional[int] = field(default=None, compare=False)

    def __post_init__(self):
        """Initialize derived fields"""
        if hasattr(self.source, 'object_id'):
            self._source_id = self.source.object_id

    def applies_to(self, obj: 'GameObject') -> bool:
        """Check if this effect applies to a specific object

        Args:
            obj: The game object to check

        Returns:
            True if this effect should modify the object
        """
        return self.affected.matches(obj, self.source, self.controller)

    def apply(self, obj: 'GameObject') -> None:
        """Apply this effect's modification to an object

        Args:
            obj: The game object to modify
        """
        self.modification.apply(obj)

    def is_expired(self, game: Optional['Game'] = None, current_turn: int = 0) -> bool:
        """Check if this effect has expired

        Args:
            game: The game state (optional, for checking zone membership)
            current_turn: The current turn number

        Returns:
            True if this effect should be removed
        """
        if self.duration == Duration.PERMANENT:
            # Check if source is still on battlefield
            if game is not None and self.source is not None:
                if hasattr(game, 'zones') and hasattr(game.zones, 'find_object'):
                    result = game.zones.find_object(self._source_id)
                    if result is None:
                        return True
                    obj, zone = result
                    if hasattr(zone, 'zone_type'):
                        if str(zone.zone_type).lower() not in ('battlefield', 'zone.battlefield'):
                            return True
            return False

        elif self.duration == Duration.END_OF_TURN:
            # Expires at end of the turn it was created
            if current_turn > self._created_turn:
                return True
            return False

        elif self.duration == Duration.NEXT_TURN:
            # Expires at end of the next turn
            if current_turn > self._created_turn + 1:
                return True
            return False

        elif self.duration == Duration.UNTIL_LEAVES:
            # Expires when source leaves the battlefield
            if game is not None and self.source is not None:
                if hasattr(game, 'zones') and hasattr(game.zones, 'find_object'):
                    result = game.zones.find_object(self._source_id)
                    if result is None:
                        return True
                    obj, zone = result
                    if hasattr(zone, 'zone_type'):
                        if str(zone.zone_type).lower() not in ('battlefield', 'zone.battlefield'):
                            return True
            return False

        elif self.duration == Duration.WHILE_ATTACHED:
            # Expires when attachment relationship ends
            if self.source is not None:
                if hasattr(self.source, 'attached_to'):
                    if self.source.attached_to is None:
                        return True
            return False

        elif self.duration == Duration.CUSTOM:
            # Use custom end condition
            if self.end_condition is not None:
                return self.end_condition()
            return False

        return False

    def has_dependency_on(self, other: 'ContinuousEffect') -> bool:
        """Check if this effect depends on another effect (CR 613.8)

        Dependency occurs when:
        1. Both effects apply in the same layer (or sublayer)
        2. Applying one effect would change what the other affects or does
        3. Neither effect is a characteristic-defining ability

        Args:
            other: The other effect to check dependency against

        Returns:
            True if this effect depends on the other effect
        """
        # Check explicit dependency list
        if other in self.dependency:
            return True

        # Effects must be in the same layer to have dependency
        if self.layer != other.layer:
            return False

        # Same sublayer check for layer 7
        if self.layer == 7 and self.sublayer != other.sublayer:
            return False

        # Additional dependency checks would go here based on what the effects do
        # This is a simplified implementation - full dependency is complex

        return False


# =============================================================================
# STATIC ABILITY CLASS (CR 604)
# =============================================================================

@dataclass
class StaticAbility:
    """A static ability that generates continuous effects (CR 604)

    Static abilities create continuous effects as long as the permanent with
    the ability is on the battlefield (or in the appropriate zone).

    Attributes:
        source: The permanent with this static ability
        creates_effect: Function that creates the continuous effect

    Example:
        # "Creatures you control get +1/+1"
        static_ability = StaticAbility(
            source=my_lord,
            creates_effect=lambda: anthem_effect(my_lord, 1, 1)
        )
    """
    source: Any
    creates_effect: Callable[[], ContinuousEffect]

    def generate_effect(self) -> ContinuousEffect:
        """Generate the continuous effect from this static ability

        Returns:
            The ContinuousEffect created by this ability
        """
        effect = self.creates_effect()
        effect.source = self.source
        effect.duration = Duration.PERMANENT
        return effect


# =============================================================================
# COMMON EFFECT FACTORY FUNCTIONS
# =============================================================================

def anthem_effect(
    source: Any,
    bonus_p: int,
    bonus_t: int,
    filter: str = "creatures_you_control"
) -> ContinuousEffect:
    """Create an anthem effect (global P/T bonus)

    Creates effects like "Creatures you control get +1/+1"

    Args:
        source: The source of the anthem effect
        bonus_p: Power bonus (can be negative)
        bonus_t: Toughness bonus (can be negative)
        filter: Filter string for affected creatures

    Returns:
        ContinuousEffect for the anthem
    """
    controller = None
    if hasattr(source, 'controller'):
        controller = source.controller
    elif hasattr(source, 'controller_id'):
        controller = source.controller_id

    return ContinuousEffect(
        source=source,
        controller=controller,
        layer=7,
        sublayer="c",  # Layer 7c: Effects that modify P/T
        duration=Duration.PERMANENT,
        affected=AffectedObjects(filter_type=filter),
        modification=Modification(
            mod_type="modify_pt",
            value=(bonus_p, bonus_t)
        )
    )


def lord_effect(
    source: Any,
    creature_type: str,
    bonus_p: int,
    bonus_t: int
) -> ContinuousEffect:
    """Create a lord effect (type-specific P/T bonus)

    Creates effects like "Other Elves you control get +1/+1"

    Args:
        source: The lord creature
        creature_type: The creature subtype to boost (e.g., "Elf", "Goblin")
        bonus_p: Power bonus
        bonus_t: Toughness bonus

    Returns:
        ContinuousEffect for the lord bonus
    """
    controller = None
    if hasattr(source, 'controller'):
        controller = source.controller
    elif hasattr(source, 'controller_id'):
        controller = source.controller_id

    source_id = None
    if hasattr(source, 'object_id'):
        source_id = source.object_id

    def lord_filter(obj: 'GameObject') -> bool:
        """Filter for other creatures of the type you control"""
        # Exclude the lord itself
        if hasattr(obj, 'object_id') and obj.object_id == source_id:
            return False

        # Must be a creature
        is_creature = False
        types = None
        if hasattr(obj, 'characteristics') and hasattr(obj.characteristics, 'types'):
            types = obj.characteristics.types
        elif hasattr(obj, 'types'):
            types = obj.types

        if types:
            for t in types:
                if str(t).lower() in ('creature', 'cardtype.creature'):
                    is_creature = True
                    break

        if not is_creature:
            return False

        # Must have the subtype
        subtypes = None
        if hasattr(obj, 'characteristics') and hasattr(obj.characteristics, 'subtypes'):
            subtypes = obj.characteristics.subtypes
        elif hasattr(obj, 'subtypes'):
            subtypes = obj.subtypes

        if subtypes:
            type_lower = creature_type.lower()
            for st in subtypes:
                if str(st).lower() == type_lower:
                    return True

        return False

    return ContinuousEffect(
        source=source,
        controller=controller,
        layer=7,
        sublayer="c",
        duration=Duration.PERMANENT,
        affected=AffectedObjects(filter_type="custom", filter_func=lord_filter),
        modification=Modification(
            mod_type="modify_pt",
            value=(bonus_p, bonus_t)
        )
    )


def keyword_granting(
    source: Any,
    keyword: str,
    filter: str = "creatures_you_control"
) -> ContinuousEffect:
    """Create a keyword-granting effect

    Creates effects like "Creatures you control have flying"

    Args:
        source: The source granting the keyword
        keyword: The keyword to grant (e.g., "flying", "trample", "lifelink")
        filter: Filter string for affected creatures

    Returns:
        ContinuousEffect for the keyword grant
    """
    controller = None
    if hasattr(source, 'controller'):
        controller = source.controller
    elif hasattr(source, 'controller_id'):
        controller = source.controller_id

    return ContinuousEffect(
        source=source,
        controller=controller,
        layer=6,  # Layer 6: Ability adding/removing
        duration=Duration.PERMANENT,
        affected=AffectedObjects(filter_type=filter),
        modification=Modification(
            mod_type="add_keyword",
            value=keyword
        )
    )


def type_changing(
    source: Any,
    new_types: List[str],
    filter: str = "self"
) -> ContinuousEffect:
    """Create a type-changing effect

    Creates effects that add types to permanents.

    Args:
        source: The source of the effect
        new_types: List of types to add
        filter: Filter string for affected objects

    Returns:
        ContinuousEffect for the type change
    """
    controller = None
    if hasattr(source, 'controller'):
        controller = source.controller
    elif hasattr(source, 'controller_id'):
        controller = source.controller_id

    return ContinuousEffect(
        source=source,
        controller=controller,
        layer=4,  # Layer 4: Type-changing
        duration=Duration.PERMANENT,
        affected=AffectedObjects(filter_type=filter),
        modification=Modification(
            mod_type="add_type",
            value=new_types
        )
    )


def color_changing(
    source: Any,
    new_colors: List[Any],
    filter: str = "self"
) -> ContinuousEffect:
    """Create a color-changing effect

    Creates effects that modify colors of permanents.

    Args:
        source: The source of the effect
        new_colors: List of colors to set
        filter: Filter string for affected objects

    Returns:
        ContinuousEffect for the color change
    """
    controller = None
    if hasattr(source, 'controller'):
        controller = source.controller
    elif hasattr(source, 'controller_id'):
        controller = source.controller_id

    return ContinuousEffect(
        source=source,
        controller=controller,
        layer=5,  # Layer 5: Color-changing
        duration=Duration.PERMANENT,
        affected=AffectedObjects(filter_type=filter),
        modification=Modification(
            mod_type="set_color",
            value=set(new_colors)
        )
    )


# =============================================================================
# ADDITIONAL UTILITY FUNCTIONS
# =============================================================================

def pump_effect(
    source: Any,
    target_id: int,
    power_mod: int,
    toughness_mod: int,
    duration: Duration = Duration.END_OF_TURN
) -> ContinuousEffect:
    """Create a temporary pump effect on a specific target

    Creates effects like "Target creature gets +3/+3 until end of turn"

    Args:
        source: The source of the pump effect
        target_id: Object ID of the target creature
        power_mod: Power modifier
        toughness_mod: Toughness modifier
        duration: How long the effect lasts

    Returns:
        ContinuousEffect for the pump
    """
    controller = None
    if hasattr(source, 'controller'):
        controller = source.controller
    elif hasattr(source, 'controller_id'):
        controller = source.controller_id

    affected = AffectedObjects(filter_type="target")
    affected.target_ids = {target_id}

    return ContinuousEffect(
        source=source,
        controller=controller,
        layer=7,
        sublayer="c",
        duration=duration,
        affected=affected,
        modification=Modification(
            mod_type="modify_pt",
            value=(power_mod, toughness_mod)
        )
    )


def control_change_effect(
    source: Any,
    target_id: int,
    new_controller: Any,
    duration: Duration = Duration.PERMANENT
) -> ContinuousEffect:
    """Create a control-changing effect

    Creates effects like "Gain control of target creature"

    Args:
        source: The source of the control effect
        target_id: Object ID of the permanent to control
        new_controller: The player gaining control
        duration: How long the effect lasts

    Returns:
        ContinuousEffect for the control change
    """
    controller = None
    if hasattr(source, 'controller'):
        controller = source.controller
    elif hasattr(source, 'controller_id'):
        controller = source.controller_id

    affected = AffectedObjects(filter_type="target")
    affected.target_ids = {target_id}

    return ContinuousEffect(
        source=source,
        controller=controller,
        layer=2,  # Layer 2: Control-changing
        duration=duration,
        affected=affected,
        modification=Modification(
            mod_type="set_controller",
            value=new_controller
        )
    )


def set_pt_effect(
    source: Any,
    target_id: int,
    power: int,
    toughness: int,
    duration: Duration = Duration.END_OF_TURN
) -> ContinuousEffect:
    """Create a set P/T effect

    Creates effects like "Target creature becomes a 0/1"

    Args:
        source: The source of the effect
        target_id: Object ID of the target creature
        power: The power to set
        toughness: The toughness to set
        duration: How long the effect lasts

    Returns:
        ContinuousEffect for the P/T setting
    """
    controller = None
    if hasattr(source, 'controller'):
        controller = source.controller
    elif hasattr(source, 'controller_id'):
        controller = source.controller_id

    affected = AffectedObjects(filter_type="target")
    affected.target_ids = {target_id}

    return ContinuousEffect(
        source=source,
        controller=controller,
        layer=7,
        sublayer="b",  # Layer 7b: Effects that set P/T
        duration=duration,
        affected=affected,
        modification=Modification(
            mod_type="set_pt",
            value=(power, toughness)
        )
    )


# =============================================================================
# EXPORTS
# =============================================================================

__all__ = [
    # Enums
    'Duration',

    # Core classes
    'AffectedObjects',
    'Modification',
    'ContinuousEffect',
    'StaticAbility',

    # Factory functions
    'anthem_effect',
    'lord_effect',
    'keyword_granting',
    'type_changing',
    'color_changing',

    # Utility functions
    'pump_effect',
    'control_change_effect',
    'set_pt_effect',
]
